type awsEc2MetadataOptions
  @generate(
    query: { get: false, query: true, aggregate: false }
    mutation: { add: false, delete: false }
    subscription: false
  ) {
  state: String!
  httpTokens: String!
  httpPutResponseHopLimit: Int
  httpEndpoint: String! @id
}

type blockDeviceEbs
  @generate(
    query: { get: false, query: true, aggregate: false }
    mutation: { add: false, delete: false }
    subscription: false
  ) {
  attachTime: String!
  deleteOnTermination: Boolean!
  status: String!
  volumeId: String! @id
}

type awsEc2Blockdevice
  @generate(
    query: { get: false, query: true, aggregate: false }
    mutation: { add: false, delete: false }
    subscription: false
  ) {
  deviceName: String! @id
  ebs: blockDeviceEbs
}

type Tag {
  key: String
  value: String
}

type awsEc2 @key(fields: "arn") {
  id: String!
  arn: String! @id
  region: String
  ami: String
  tenancy: String
  elasticIps: String
  publicDns: String
  privateDns: String
  monitoring: String
  privateIps: String
  keyPairName: String
  cpuCoreCount: Int
  hibernation: String
  ebsOptimized: String
  ipv4PublicIp: String
  instanceType: String
  ipv6Addresses: [String]
  placementGroup: String
  instanceState: String
  sourceDestCheck: String
  availabilityZone: String
  cpuThreadsPerCore: Int
  iamInstanceProfile: String
  deletionProtection: String
  primaryNetworkInterface: String
  metadataOptions: awsEc2MetadataOptions
  metadatasecurityGroupIdsOptions: [String]
  securityGroupIds: [String]
  ephemeralBlockDevice: [awsEc2Blockdevice]
  associatePublicIpAddress: String
  tags: [Tag]
  alb: [awsAlb] @hasInverse(field: ec2Instance)
  securityGroups: [awsSecurityGroup] @hasInverse(field: ec2Instance)
  ebs: [awsEbs] @hasInverse(field: ec2Instance)
  eip: [awsEip] @hasInverse(field: ec2Instance)
  networkInterfaces: [awsNetworkInterface] @hasInverse(field: ec2Instance)
}
